<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<script>
  window.Vaadin = window.Vaadin || {};

  /**
   * A mixin for `nav` elements, facilitating navigation and selection of childNodes.
   *
   * @polymerMixin
   */
  Vaadin.ListMixin = superClass => class VaadinListMixin extends superClass {
    static get properties() {
      return {
        /**
         * The index of the item selected in the items array
         */
        selected: {
          type: Number,
          value: 0,
          reflectToAttribute: true,
          notify: true,
          observer: '_selectedChanged'
        },
        /**
         * When true changes the disposition of items in dom from horizontal
         * to vertical.
         * It also changes navigation keys from left/right to up/down.
         */
        vertical: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
          observer: '_verticalChanged'
        }
      };
    }

    ready() {
      super.ready();
      this.addEventListener('selected', e => this._onSelected(e));
      this.addEventListener('keydown', e => this._onKeydown(e));

      if (this._navItems.length) {
        this._selectedChanged(this.selected);
        this._setFocusable(this.selected);
      }
    }

    _verticalChanged(vertical) {
      this.setAttribute('aria-orientation', vertical ? 'vertical' : 'horizontal');
    }

    get focused() {
      return this.getRootNode().activeElement;
    }

    get _navItems() {
      return Array.from(this.childNodes)
        .filter(e => Vaadin.TabElement && e instanceof Vaadin.TabElement);
    }

    _onKeydown(event) {
      if (event.metaKey || event.shiftKey || event.ctrlKey) {
        return;
      }

      // IE names for arrows do not include the Arrow prefix
      const key = event.key.replace(/^Arrow/, '');
      const items = this._navItems;
      const currentIdx = items.indexOf(this.focused);
      let condition = item => !item.disabled;
      let idx, increment;

      if (this.vertical && key === 'Up' || !this.vertical && key === 'Left') {
        increment = -1;
        idx = currentIdx - 1;
      } else if (this.vertical && key === 'Down' || !this.vertical && key === 'Right') {
        increment = 1;
        idx = currentIdx + 1;
      } else if (key === 'Home') {
        increment = 1;
        idx = 0;
      } else if (key === 'End') {
        increment = -1;
        idx = this._navItems.length - 1;
      } else if (key.length == 1) {
        increment = 1;
        idx = currentIdx + 1;
        condition = item => !item.disabled &&
          item.textContent.toLowerCase().indexOf(key.toLowerCase()) === 0;
      }

      if (increment) {
        const totalItems = items.length;
        for (let i = 0; i < totalItems; i++, idx += increment) {
          if (idx < 0) {
            idx = totalItems - 1;
          } else if (idx >= totalItems) {
            idx = 0;
          }

          const item = items[idx];
          if (condition(item)) {
            this._focus(idx);
            event.preventDefault();
            return;
          }
        }
      }
    }

    _setFocusable(idx) {
      const items = this._navItems;
      items.forEach(e => e.tabIndex = e === items[idx] ? 0 : -1);
    }

    _focus(idx) {
      const items = this._navItems;
      items.forEach(e => e.focused = e === items[idx]);
      this._setFocusable(idx);
      this._scrollToItem(idx);
      items[idx].focus();
    }

    _getScrollOffsetOfNextItem(idx, side) {
      if (!this._navItems[idx + 1]) {
        return;
      }

      const nextItemRect = this._navItems[idx + 1].getBoundingClientRect();
      const scrollerRect = this.$.scroll.getBoundingClientRect();

      return nextItemRect[side] > scrollerRect[side] && nextItemRect[side] - scrollerRect[side];
    }

    _getScrollOffsetOfPrevItem(idx, side) {
      if (!this._navItems[idx - 1]) {
        return;
      }

      const prevItemRect = this._navItems[idx - 1].getBoundingClientRect();
      const scrollerRect = this.$.scroll.getBoundingClientRect();

      return scrollerRect[side] > prevItemRect[side] && prevItemRect[side] - scrollerRect[side];
    }

    // Scroll the container to have the next item by the edge of the viewport
    _scrollToItem(idx) {
      const itemRect = this._navItems[idx].getBoundingClientRect();
      const scrollerRect = this.$.scroll.getBoundingClientRect();
      var scrollDistance;

      if (!this.vertical) {
        const scrollDistanceRight = this._getScrollOffsetOfNextItem(idx, 'right');
        const scrollDistanceLeft = this._getScrollOffsetOfPrevItem(idx, 'left');

        if (itemRect.right > scrollerRect.right) {
          scrollDistance = (scrollDistanceRight) ? scrollDistanceRight : itemRect.right - scrollerRect.right;
          this._scroll(scrollDistance);

        } else if (scrollDistanceRight) {
          this._scroll(scrollDistanceRight);

        } else if (scrollerRect.left > itemRect.left) {
          scrollDistance = (scrollDistanceLeft) ? scrollDistanceLeft : itemRect.left - scrollerRect.left;
          this._scroll(scrollDistance);

        } else if (scrollDistanceLeft) {
          this._scroll(scrollDistanceLeft);

        }
      } else {
        const scrollDistanceTop = this._getScrollOffsetOfPrevItem(idx, 'top');
        const scrollDistanceBottom = this._getScrollOffsetOfNextItem(idx, 'bottom');

        if (itemRect.top < scrollerRect.top) {
          scrollDistance = (scrollDistanceTop) ? scrollDistanceTop : itemRect.top - scrollerRect.top;
          this._scroll(scrollDistance);

        } else if (scrollDistanceTop) {
          this._scroll(scrollDistanceTop);

        } else if (itemRect.bottom > scrollerRect.bottom) {
          scrollDistance = (scrollDistanceBottom) ? scrollDistanceBottom : itemRect.bottom - scrollerRect.bottom;
          this._scroll(scrollDistance);

        } else if (scrollDistanceBottom) {
          this._scroll(scrollDistanceBottom);

        }
      }
    }

    _selectedChanged(idx) {
      const items = this._navItems;
      items[idx] && items.forEach(e => e.selected = e === items[idx]);
      this._scrollToItem(idx);
    }

    _onSelected(e) {
      if (!e.detail) {
        // Prevent the user to unselect the current item
        e.target.selected = true;
      } else {
        this.selected = this._navItems.indexOf(e.target);
      }
    }
  };
</script>
